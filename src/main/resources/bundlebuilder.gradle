import java.nio.file.Files
import java.nio.file.NoSuchFileException
import java.nio.file.Paths
import java.util.regex.Pattern
import java.util.zip.ZipFile

private static def readBundleManifest(java.nio.file.Path bundlePath) {
    if (bundlePath.toFile().isDirectory()) {
        new FileInputStream(bundlePath.resolve("META-INF").resolve("MANIFEST.MF").toFile()).withCloseable {
            return new java.util.jar.Manifest(it)
        }
    } else {
        new ZipFile(bundlePath.toFile()).withCloseable {
            it.getInputStream(it.getEntry("META-INF/MANIFEST.MF")).withCloseable {
                return new java.util.jar.Manifest(it)
            }
        }
    }
}

private static List<String> readReexportedRequiredBundles(java.util.jar.Manifest manifest) {
    final def reexportedBundlePattern = Pattern.compile('(^|,)([^;]+);(bundle-version[^;]+;)?visibility:=reexport')
    final def bundlesListAttribute = manifest.getMainAttributes().getValue("Require-Bundle");
    if (bundlesListAttribute == null) {
        return Collections.emptyList()
    }
    def matcher = reexportedBundlePattern.matcher(bundlesListAttribute);
    def returnedBundles = new ArrayList<String>();
    for (int startIndex = 0; matcher.find(startIndex); startIndex = matcher.end()) {
        returnedBundles.add(matcher.group(2));
    }
    return returnedBundles;
}

private static List<String> readBundleClasspath(java.util.jar.Manifest manifest) {
    final def bundlesListAttribute = manifest.getMainAttributes().getValue("Bundle-ClassPath");
    if (bundlesListAttribute == null) {
        return Collections.emptyList()
    }
    return bundlesListAttribute.split(",")
}

private def analyzeBundleForTransitiveDependencies(java.nio.file.Path ofBundle, Set<String> alreadyImportedBundles) {
    final def manifest = readBundleManifest(ofBundle);
    def requiredBundles = readReexportedRequiredBundles(manifest)
    def bundleJarsToAdd = files()
    def nestedJarsOnClasspath = readBundleClasspath(manifest)
    if (!nestedJarsOnClasspath.isEmpty()) {
        FileCollection jarFileTree;
        if (ofBundle.toFile().isDirectory()) {
            jarFileTree = files(ofBundle)
        } else {
            jarFileTree = zipTree(ofBundle)
        }
        bundleJarsToAdd += jarFileTree.filter { it.toString().endsWithAny((String[]) nestedJarsOnClasspath.toArray()) }
    }

    requiredBundles.stream()
            .map({ recurseP2bundle(it, alreadyImportedBundles) })
            .forEach({ bundleJarsToAdd += it })
    return bundleJarsToAdd
}

private def recurseP2bundle(String name, Set<String> alreadyImportedBundles) {
    if (!alreadyImportedBundles.add(name)) {
        return Collections.emptySet()
    }
    def pluginsFolder = Paths.get(rootProject.p2Root).resolve('plugins')
    def jarFile = Files.walk(pluginsFolder, 1)
            .filter({ it.getName(it.getNameCount() - 1).toString().startsWith(name + '_') })
            .sorted({ a, b -> -a.toString().compareToIgnoreCase(b.toString()) })
            .findFirst()
            .orElseThrow({ new NoSuchFileException(pluginsFolder.resolve(name + '.jar').toString()) })

    FileCollection dependencies
    if (jarFile.toFile().isDirectory()) {
        dependencies = files(jarFile).filter { File file -> file.getName().endsWith('.class') }
    } else {
        dependencies = files(jarFile)
    }
    dependencies += analyzeBundleForTransitiveDependencies(jarFile, alreadyImportedBundles)
    return dependencies;
}

ext.cachedResolvedBundles = new HashMap<String, FileCollection>()

def p2bundle(String name, String version = '') {
    if (rootProject.cachedResolvedBundles.containsKey(name + version)) {
        return rootProject.cachedResolvedBundles.get(name + version);
    }
    def resolvedDependencies = recurseP2bundle(name, new HashSet<>())
    rootProject.cachedResolvedBundles.put(name + version, resolvedDependencies)
    return resolvedDependencies
}







