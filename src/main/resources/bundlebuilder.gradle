import java.nio.file.Files
import java.nio.file.Paths
import java.util.regex.Pattern
import java.util.stream.Collectors
import java.util.zip.ZipFile

class Properties {
    static reexportedBundlePattern =
            Pattern.compile('([\\w-._]+)(;[\\w-]+:?=("[^"]+"|[^,;]+))*')
    static cachedResolvedBundles = new HashMap<String, FileCollection>()
}

private static def readBundleManifest(java.nio.file.Path bundlePath) {
    if (bundlePath.toFile().isDirectory()) {
        new FileInputStream(bundlePath.resolve("META-INF").resolve("MANIFEST.MF").toFile()).withCloseable {
            return new java.util.jar.Manifest(it)
        }
    } else {
        new ZipFile(bundlePath.toFile()).withCloseable {
            it.getInputStream(it.getEntry("META-INF/MANIFEST.MF")).withCloseable {
                return new java.util.jar.Manifest(it)
            }
        }
    }
}

private static List<String> readReexportedRequiredBundles(java.util.jar.Manifest manifest) {
    final def bundlesListAttribute = manifest.getMainAttributes().getValue("Require-Bundle");
    if (bundlesListAttribute == null) {
        return Collections.emptyList()
    }
    return Properties
            .reexportedBundlePattern
            .matcher(bundlesListAttribute)
            .results()
            .filter({ it.group().contains("visibility:=reexport") && !it.group().contains("resolution:=optional") })
            .map({ it.group(1) })
            .collect(Collectors.toList())
}

private static List<String> readBundleClasspath(java.util.jar.Manifest manifest) {
    final def bundlesListAttribute = manifest.getMainAttributes().getValue("Bundle-ClassPath");
    if (bundlesListAttribute == null) {
        return Collections.emptyList()
    }
    return bundlesListAttribute.split(",")
}

private def analyzeBundleForTransitiveDependencies(java.nio.file.Path ofBundle, Set<String> alreadyImportedBundles) {
    final def manifest = readBundleManifest(ofBundle);
    def requiredBundles = readReexportedRequiredBundles(manifest)
    def bundleJarsToAdd = files()
    def nestedJarsOnClasspath = readBundleClasspath(manifest)
    if (!nestedJarsOnClasspath.isEmpty()) {
        FileCollection jarFileTree;
        if (ofBundle.toFile().isDirectory()) {
            jarFileTree = files(ofBundle)
        } else {
            jarFileTree = zipTree(ofBundle)
        }
        bundleJarsToAdd += jarFileTree.filter { it.toString().endsWithAny((String[]) nestedJarsOnClasspath.toArray()) }
    }

    requiredBundles.stream()
            .map({ recurseP2bundle(it, alreadyImportedBundles) })
            .forEach({ bundleJarsToAdd += it })
    return bundleJarsToAdd
}

private def recurseP2bundle(String name, Set<String> alreadyImportedBundles) {
    if (!alreadyImportedBundles.add(name)) {
        return files()
    }
    def pluginsFolder = Paths.get(rootProject.p2Root).resolve('plugins')
    def jarFile = Files.walk(pluginsFolder, 1)
            .filter({ it.getName(it.getNameCount() - 1).toString().startsWith(name + '_') })
            .sorted({ a, b -> -a.toString().compareToIgnoreCase(b.toString()) })
            .findFirst()
            .orElseGet({
                println 'Couldnt find (maybe optional?) bundle + ' name
                return null
            })
    if (jarFile == null) {
        return files()
    }

    FileCollection dependencies
    if (jarFile.toFile().isDirectory()) {
        dependencies = files(jarFile).filter { File file -> file.getName().endsWith('.class') }
    } else {
        dependencies = files(jarFile)
    }
    dependencies += analyzeBundleForTransitiveDependencies(jarFile, alreadyImportedBundles)
    return dependencies;
}

def p2bundle(String name, String version = '') {
    def cacheKey = name + version
    if (Properties.cachedResolvedBundles.containsKey(cacheKey)) {
        return Properties.cachedResolvedBundles.get(cacheKey)
    }
    def resolvedDependencies = recurseP2bundle(name, new HashSet<>())
    Properties.cachedResolvedBundles.put(cacheKey, resolvedDependencies)
    return resolvedDependencies
}







